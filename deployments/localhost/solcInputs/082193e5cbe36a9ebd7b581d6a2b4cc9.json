{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IChainlinkAggregatorV3 {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/TBDETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport './interfaces/IHegicETHOptions.sol';\nimport './interfaces/ICurve.sol';\nimport './interfaces/IUniswapV2Router02.sol';\nimport './interfaces/IChainlinkAggregatorV3.sol';\nimport './interfaces/IERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './interfaces/IWETH.sol';\n\ncontract TBDETH {\n    using SafeMath for uint256;\n\n    ICurve alUSDMetaPool;\n    IHegicETHOptions hegicETHOptions;\n    IUniswapV2Router02 uniswapV2Router02;\n    IERC20 alUSD;\n    IERC20 Dai;\n    IWETH Weth;\n    address[] public uniswapExchangePath;\n    uint256 constant PRICE_DECIMALS = 1e8;\n\n    event PurchaseOption(address indexed owner, uint256 optionID, uint256 purchasePrice, address purchaseToken, uint256 fees);\n\n    constructor(\n        address _hegicETHOptions,\n        address _alUSD,\n        address _Dai,\n        address _Weth,\n        address _alUSDMetaPool,\n        address _uniswapV2Router02\n    ) {\n        alUSDMetaPool = ICurve(_alUSDMetaPool);\n        hegicETHOptions = IHegicETHOptions(_hegicETHOptions);\n        alUSD = IERC20(_alUSD);\n        Dai = IERC20(_Dai);\n        Weth = IWETH(_Weth);\n        uniswapV2Router02 = IUniswapV2Router02(_uniswapV2Router02);\n\n        uniswapExchangePath = new address[](2);\n        uniswapExchangePath[0] = _Dai;\n        uniswapExchangePath[1] = _Weth;\n    }\n\n    function purchaseEthOptionWithAlUSD(\n        uint256 amount,\n        uint256 strike,\n        uint256 period,\n        address owner,\n        IHegicETHOptions.OptionType optionType,\n        uint256 minETH\n    ) public returns (uint256 optionID) {\n        require(alUSD.transferFrom(msg.sender, address(this), amount), 'TBD/cannot-transfer-alusd');\n\n        uint256 curveDyInDai = alUSDMetaPool.get_dy_underlying(0, 1, amount);\n        alUSD.approve(address(alUSDMetaPool), amount);\n        require(\n            alUSDMetaPool.exchange_underlying(int128(0), int128(1), amount, curveDyInDai) == curveDyInDai,\n            'TBD/cannot-swap-alusd-to-dai'\n        );\n\n        Dai.approve(address(uniswapV2Router02), curveDyInDai);\n\n        uint256[] memory uniswapAmounts = uniswapV2Router02.swapExactTokensForETH(\n            curveDyInDai,\n            minETH,\n            uniswapExchangePath,\n            address(this),\n            block.timestamp\n        );\n\n\n        uint256 optionAmount = getAmount(period, uniswapAmounts[1], strike, optionType);\n\n        optionID = hegicETHOptions.create{value: uniswapAmounts[1]}(period, optionAmount, strike, optionType);\n        hegicETHOptions.transfer(optionID, payable(owner));\n\n        emit PurchaseOption(owner, optionID, amount, address(alUSD), uniswapAmounts[1]);\n\n        return optionID;\n    }\n\n    receive() external payable {}\n\n    function getEthAmountFromAlUSD(uint256 amount) external view returns (uint256) {\n        uint256 curveDyInDai = alUSDMetaPool.get_dy_underlying(0, 1, amount);\n        uint256[] memory uniswapWethOutput = uniswapV2Router02.getAmountsOut(curveDyInDai, uniswapExchangePath);\n        return uniswapWethOutput[1];\n    }\n\n    function getAmount(\n        uint256 period,\n        uint256 fees,\n        uint256 strike,\n        IHegicETHOptions.OptionType optionType\n    ) public view returns (uint256) {\n        require(\n            optionType == IHegicETHOptions.OptionType.Put || optionType == IHegicETHOptions.OptionType.Call,\n            'invalid option type'\n        );\n        (, int256 latestPrice, , , ) = IChainlinkAggregatorV3(hegicETHOptions.priceProvider()).latestRoundData();\n        uint256 currentPrice = uint256(latestPrice);\n        uint256 iv = hegicETHOptions.impliedVolRate();\n\n        if (optionType == IHegicETHOptions.OptionType.Put) {\n            if (strike > currentPrice) {\n                // ITM Put Fee\n                uint256 nume = fees.mul(currentPrice).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = currentPrice.mul(PRICE_DECIMALS).div(100);\n                denom = denom.add(sqrtPeriod.mul(iv).mul(strike));\n                denom = denom.add(PRICE_DECIMALS.mul(strike.sub(currentPrice)));\n                return nume.div(denom);\n            } else {\n                // OTM Put Fee\n                uint256 nume = fees.mul(currentPrice).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = sqrtPeriod.mul(strike).mul(iv).add(currentPrice.mul(PRICE_DECIMALS).div(100));\n                return nume.div(denom);\n            }\n        } else {\n            if (strike < currentPrice) {\n                // ITM Call Fee\n                uint256 nume = fees.mul(strike).mul(PRICE_DECIMALS).mul(currentPrice);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = strike.mul(PRICE_DECIMALS).div(100).mul(currentPrice);\n                denom = denom.add(sqrtPeriod.mul(iv).mul(currentPrice).mul(currentPrice));\n                denom = denom.add(strike.mul(PRICE_DECIMALS).mul(currentPrice.sub(strike)));\n                return nume.div(denom);\n            } else {\n                // OTM Call Fee\n                uint256 nume = fees.mul(strike).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = sqrtPeriod.mul(currentPrice).mul(iv).add(strike.mul(PRICE_DECIMALS).div(100));\n                return nume.div(denom);\n            }\n        }\n    }\n\n    /**\n     * @return result Square root of the number\n     */\n    function sqrt(uint256 x) private pure returns (uint256 result) {\n        result = x;\n        uint256 k = x.div(2).add(1);\n        while (k < result) (result, k) = (k, x.div(k).add(k).div(2));\n    }\n\n}\n"
    },
    "contracts/interfaces/IHegicETHOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IHegicETHOptions {\n    function priceProvider() external view returns (address);\n\n    function impliedVolRate() external view returns (uint256);\n\n    enum OptionType {Invalid, Put, Call}\n\n    enum State {Inactive, Active, Exercised, Expired}\n\n    function exercise(uint256 optionID) external;\n\n    function options(uint256)\n        external\n        view\n        returns (\n            State state,\n            address payable holder,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            uint256 premium,\n            uint256 expiration,\n            OptionType optionType\n        );\n\n    struct Option {\n        State state;\n        address payable holder;\n        uint256 strike;\n        uint256 amount;\n        uint256 lockedAmount;\n        uint256 premium;\n        uint256 expiration;\n        OptionType optionType;\n    }\n\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        OptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n\n    function create(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        OptionType optionType\n    ) external payable returns (uint256 optionID);\n\n    function transfer(uint256 optionID, address payable newHolder) external;\n}\n"
    },
    "contracts/interfaces/ICurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface ICurve {\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IUniswapV2Router02 {\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\n\nfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IERC20 {\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport './IERC20.sol';\n\ninterface IWETH is IERC20 {\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/TBDBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport './interfaces/IHegicBTCOptions.sol';\nimport './interfaces/ICurve.sol';\nimport './interfaces/IUniswapV2Router02.sol';\nimport './interfaces/IChainlinkAggregatorV3.sol';\nimport './interfaces/IERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './interfaces/IWETH.sol';\n\ncontract TBDBTC {\n    using SafeMath for uint256;\n\n    ICurve alUSDMetaPool;\n    IHegicBTCOptions hegicBTCOptions;\n    IUniswapV2Router02 uniswapV2Router02;\n    IERC20 alUSD;\n    IERC20 Dai;\n    IERC20 Wbtc;\n    IWETH Weth;\n    address[] public uniswapExchangePath;\n    address[] public uniswapBtcExchangePath;\n    uint256 constant PRICE_DECIMALS = 1e8;\n\n    event PurchaseOption(address indexed owner, uint256 optionID, uint256 purchasePrice, address purchaseToken, uint256 fees);\n\n    constructor(\n        address _hegicBTCOptions,\n        address _alUSD,\n        address _Dai,\n        address _Weth,\n        address _Wbtc,\n        address _alUSDMetaPool,\n        address _uniswapV2Router02\n    ) {\n        alUSDMetaPool = ICurve(_alUSDMetaPool);\n        hegicBTCOptions = IHegicBTCOptions(_hegicBTCOptions);\n        alUSD = IERC20(_alUSD);\n        Dai = IERC20(_Dai);\n        Weth = IWETH(_Weth);\n        Wbtc = IERC20(_Wbtc);\n        uniswapV2Router02 = IUniswapV2Router02(_uniswapV2Router02);\n\n        uniswapExchangePath = new address[](2);\n        uniswapExchangePath[0] = _Dai;\n        uniswapExchangePath[1] = _Weth;\n\n        uniswapBtcExchangePath = new address[](2);\n        uniswapBtcExchangePath[0] = _Weth;\n        uniswapBtcExchangePath[1] = _Wbtc;\n    }\n\n    function purchaseBtcOptionWithAlUSD(\n        uint256 amount,\n        uint256 strike,\n        uint256 period,\n        address owner,\n        IHegicBTCOptions.OptionType optionType,\n        uint256 minETH\n    ) public returns (uint256 optionID) {\n        require(alUSD.transferFrom(msg.sender, address(this), amount), 'TBD/cannot-transfer-alusd');\n\n        uint256 curveDyInDai = alUSDMetaPool.get_dy_underlying(0, 1, amount);\n        alUSD.approve(address(alUSDMetaPool), amount);\n        require(\n            alUSDMetaPool.exchange_underlying(int128(0), int128(1), amount, curveDyInDai) == curveDyInDai,\n            'TBD/cannot-swap-alusd-to-dai'\n        );\n\n        Dai.approve(address(uniswapV2Router02), curveDyInDai);\n\n        uint256[] memory uniswapAmounts = uniswapV2Router02.swapExactTokensForETH(\n            curveDyInDai,\n            minETH,\n            uniswapExchangePath,\n            address(this),\n            block.timestamp\n        );\n\n\n        uint256 optionAmount = getAmount(period, uniswapAmounts[1], strike, optionType);\n\n        optionID = hegicBTCOptions.create{value: uniswapAmounts[1]}(period, optionAmount, strike, optionType);\n        hegicBTCOptions.transfer(optionID, payable(owner));\n\n        emit PurchaseOption(owner, optionID, amount, address(alUSD), uniswapAmounts[1]);\n\n        return optionID;\n    }\n\n    receive() external payable {}\n\n    function getEthAmountFromAlUSD(uint256 amount) external view returns (uint256) {\n        uint256 curveDyInDai = alUSDMetaPool.get_dy_underlying(0, 1, amount);\n        return uniswapV2Router02.getAmountsOut(curveDyInDai, uniswapExchangePath)[1];\n    }\n\n    function getBtcAmountFromAlUSD(uint256 amount) external view returns (uint256) {\n        uint256 curveDyInDai = alUSDMetaPool.get_dy_underlying(0, 1, amount);\n        uint256[] memory uniswapWethOutput = uniswapV2Router02.getAmountsOut(curveDyInDai, uniswapExchangePath);\n        return uniswapV2Router02.getAmountsOut(uniswapWethOutput[1], uniswapBtcExchangePath)[1];\n    }\n\n    function getAmount(\n        uint256 period,\n        uint256 fees,\n        uint256 strike,\n        IHegicBTCOptions.OptionType optionType\n    ) public view returns (uint256) {\n        require(\n            optionType == IHegicBTCOptions.OptionType.Put || optionType == IHegicBTCOptions.OptionType.Call,\n            'invalid option type'\n        );\n        (, int256 latestPrice, , , ) = IChainlinkAggregatorV3(hegicBTCOptions.priceProvider()).latestRoundData();\n        uint256 currentPrice = uint256(latestPrice);\n        uint256 iv = hegicBTCOptions.impliedVolRate();\n        uint256 convertedFees = uniswapV2Router02.getAmountsOut(fees, uniswapBtcExchangePath)[1];\n\n        if (optionType == IHegicBTCOptions.OptionType.Put) {\n            if (strike > currentPrice) {\n                // ITM Put Fee\n                uint256 nume = convertedFees.mul(currentPrice).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = currentPrice.mul(PRICE_DECIMALS).div(100);\n                denom = denom.add(sqrtPeriod.mul(iv).mul(strike));\n                denom = denom.add(PRICE_DECIMALS.mul(strike.sub(currentPrice)));\n                return nume.div(denom);\n            } else {\n                // OTM Put Fee\n                uint256 nume = convertedFees.mul(currentPrice).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = sqrtPeriod.mul(strike).mul(iv).add(currentPrice.mul(PRICE_DECIMALS).div(100));\n                return nume.div(denom);\n            }\n        } else {\n            if (strike < currentPrice) {\n                // ITM Call Fee\n                uint256 nume = convertedFees.mul(strike).mul(PRICE_DECIMALS).mul(currentPrice);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = strike.mul(PRICE_DECIMALS).div(100).mul(currentPrice);\n                denom = denom.add(sqrtPeriod.mul(iv).mul(currentPrice).mul(currentPrice));\n                denom = denom.add(strike.mul(PRICE_DECIMALS).mul(currentPrice.sub(strike)));\n                return nume.div(denom);\n            } else {\n                // OTM Call Fee\n                uint256 nume = convertedFees.mul(strike).mul(PRICE_DECIMALS);\n                uint256 sqrtPeriod = sqrt(period);\n                uint256 denom = sqrtPeriod.mul(currentPrice).mul(iv).add(strike.mul(PRICE_DECIMALS).div(100));\n                return nume.div(denom);\n            }\n        }\n    }\n\n    /**\n     * @return result Square root of the number\n     */\n    function sqrt(uint256 x) private pure returns (uint256 result) {\n        result = x;\n        uint256 k = x.div(2).add(1);\n        while (k < result) (result, k) = (k, x.div(k).add(k).div(2));\n    }\n\n}\n"
    },
    "contracts/interfaces/IHegicBTCOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IHegicBTCOptions {\n    function priceProvider() external view returns (address);\n\n    function impliedVolRate() external view returns (uint256);\n\n    enum OptionType {Invalid, Put, Call}\n\n    enum State {Inactive, Active, Exercised, Expired}\n\n    function exercise(uint256 optionID) external;\n\n    function options(uint256)\n        external\n        view\n        returns (\n            State state,\n            address payable holder,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            uint256 premium,\n            uint256 expiration,\n            OptionType optionType\n        );\n\n    struct Option {\n        State state;\n        address payable holder;\n        uint256 strike;\n        uint256 amount;\n        uint256 lockedAmount;\n        uint256 premium;\n        uint256 expiration;\n        OptionType optionType;\n    }\n\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        OptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 totalETH,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n\n    function create(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        OptionType optionType\n    ) external payable returns (uint256 optionID);\n\n    function transfer(uint256 optionID, address payable newHolder) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}